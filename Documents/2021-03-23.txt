Computed Properties and Watchers:

1)Computed Caching vs Methods:
-Instead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. 
-the difference is that computed properties are cached based on their reactive dependencies. 
-A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as message has not changed, multiple access to the reversedMessage computed property will immediately return the previously computed result without having to run the function again.


2)Computed Setter:
-computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}

3)watcher:
-When the data changes we want to do something, like printing a console log.