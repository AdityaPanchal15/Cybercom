------List Rendering--------

1)Array Change Detection:
  -Replacing an Array:
    Mutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. 
filter(), 
concat() and 
slice(), 
which do not mutate the original array but always return a new array.

Ex.,computed: {
    FooItem: {
      get() {
         return this.items.filter((item)=> {return item.message.match(/B/)});
      },
    },
  },


2)Displaying Filtered/Sorted Results:
 -Sometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.


3)v-for with a Range:-
-ex.,<div>
      <span v-for="n in 10" :key="n">{{ n }} </span>
    </div>

4)v-for on a <template>:-
-ex.,<ul>
      <template v-for="item in ToDoItems">
        <li :key="item.id">{{ item.label }}</li>
      </template>
    </ul>

5)v-for with v-if:-
    <ul v-if="ToDoItems.length">
      <li v-for="todo in ToDoItems" :key="todo.id">
        {{ todo.label }}
      </li>
    </ul>
    <p v-else>No todos left!</p>

6)v-for with a Component:-
<my-component v-for="item in items" :key="item.id"></my-component>


----------------Event Handling-----------------------
1)event modifiers:-
-.stop
.prevent
.capture
.self
.once
.passive

2)Key Modifiers:-
When listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for v-on when listening for key events:

<!-- only call `vm.submit()` when the `key` is `Enter` -->
<input v-on:keyup.enter="submit">

-Vue provides aliases for the most commonly used key codes when necessary for legacy browser support:
.enter
.tab
.delete (captures both “Delete” and “Backspace” keys)
.esc
.space
.up
.down
.left
.right

-You can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:

.ctrl
.alt
.shift
.meta

Ex.,
<!-- Alt + C -->
<input v-on:keyup.alt.67="clear">

<!-- Ctrl + Click -->
<div v-on:click.ctrl="doSomething">Do something</div>


3).exact modifier:-
-The .exact modifier allows control of the exact combination of system modifiers needed to trigger an event.
Ex.,
<!-- this will fire even if Alt or Shift is also pressed -->
<button v-on:click.ctrl="onClick">A</button>

<!-- this will only fire when Ctrl and no other keys are pressed -->
<button v-on:click.ctrl.exact="onCtrlClick">A</button>

<!-- this will only fire when no system modifiers are pressed -->
<button v-on:click.exact="onClick">A</button>

4)Mouse Button Modifiers
.left
.right
.middle
These modifiers restrict the handler to events triggered by a specific mouse button.


-----------------Form Input Binding------------------
You can use the v-model directive to create two-way data bindings on form input, textarea, and select elements. It automatically picks the correct way to update the element based on the input type.
use v-model.

1)Value Bindings
-For radio, checkbox and select options, the v-model binding values are usually static strings (or booleans for checkboxes):

<!-- `picked` is a string "a" when checked -->
<input type="radio" v-model="picked" value="a">

<!-- `toggle` is either true or false -->
<input type="checkbox" v-model="toggle"  true-value="yes" false-value="no">

<!-- `selected` is a string "abc" when the first option is selected -->
<select v-model="selected">
  <option value="abc">ABC</option>
</select>

2)modifiers:
-.lazy:-By default, v-model syncs the input with the data after each input event.You can add the lazy modifier to instead sync after change events.

-.number:-If you want user input to be automatically typecast as a Number, you can add the number modifier to your v-model managed inputs.	
This is often useful, because even with type="number", the value of HTML input elements always returns a string. 

-.trim:-If you want whitespace from user input to be trimmed automatically, you can add the trim modifier to your v-model-managed inputs

--------------------------component basic-------------------------
1)Content distribution with slote:
-Just like with HTML elements, it’s often useful to be able to pass content to a component, like this:
ex.,App.vue
     <component-basic>Content distribution with slote</component-basic>

   ComponentBasic.vue
	<template>
	  <div>
	    <slot></slot>
	  </div>  
	</template>

2)v-bind:is:-
<!-- Component changes when currentTabComponent changes -->
<component v-bind:is="currentTabComponent"></component>

In the example above, currentTabComponent can contain either:
the name of a registered component, or
a component’s options object

3)custom component with v-model:-
-it will work ass input component.
